#pragma once 
#include <stdio.h> // 표준 입출력 라이브러리 헤더 포함

class CCebMatrix // 행렬의 연산을 계산하는 클래스 정의
{
	int m_rows;// 행의 갯수를 저장하는 정수형 변수
	int m_cols;// 열의 갯수를 저장하는 정수형 변수
	double **m_elem; // 행렬의 각 항목 값을 지정해 값의 내용을 넣어주는 더블포인터 실수형 변수

public:
	CCebMatrix(void) : m_rows(0), m_cols(0), m_elem(NULL){} 
	// 생성자(객체가 생성될 때는 m_rows와 m_cols를 0으로 초기화 하고, m_elem을 NULL로 초기화한다)
	~CCebMatrix(void){DeleteMem();} // 소멸자(객체가 소멸할 때는 DeleteMem()라는 함수를 호출시킨다)
	
	
	void AllocMem(int r, int c){ // 행렬을 생성하기 위해 실제 메모리를 할당하는 함수
		if(r <= 0 || c <= 0){ // 만약 행과 열이 0보다 작거나 같으면
			printf("\t메모리를 할당할 수 없습니다\n"); // 메모리를 할당할 수 없다는 경고문과 함께 return 한다
			return;
		}  
		if(m_elem != NULL )  DeleteMem(); 
		// 행렬의 값을 넣는 m_elem이 NULL로 초기화된 상태여야 한다. 
		// 만약, m_elem이 NULL로 제대로 초기화 되지 않았다면, DeleMem() 함수를 호출해 m_elem 메모리를 해제시킨다(남아있는 메모리 정리)

		/*위의 조건을 검사한 후에는, 다음과 같이 수행한다*/
		m_rows = r;  // r의 값이 정상적으로 들어왔으므로, 클래스의 멤버변수 m_rows에 대입시킨다.
		m_cols = c; // c의 값이 정상적으로 들어왔으므로, 클래스의 멤버변수 m_colsd에 대입시킨다.

		/*m_elem은 이차원 배열이므로, 다음과 같이 메모리를 할당해야한다*/
		m_elem = new double* [m_rows]; // 먼저, m_elem에 행의 갯수에 해당하는 만큼 메모리를 할당시킨뒤에
		for(int i =0;i<m_rows;i++) // 반복문을 통해 0부터 그 행의 갯수-1까지 돌면서
			m_elem[i] = new double[m_cols]; // 각각의 행에 열의 갯수만큼 메모리를 할당시킨다
	}

	void DeleteMem(){ // 행렬을 지우기 위해 실제 메모리를 해제시키는 함수
		
		if(m_elem != NULL){ // 만약 m_elem에 값이 들어있으면 다음과 같이 실행한다 
			for(int i = 0; i < m_rows ; i++) // 반복문을 0부터 m_rows-1 까지 돌면서 
			{
				delete []m_elem[i]; // double* 형 배열을 해제시킨다
			}
 			delete []m_elem; // 그리고 double** 형 배열을 해제시킨다
			// 이차원 배열은 배열 자체를 가리키는 포인터와 배열 안에 행을 가리키는 포인터로, 이중 포인터를 사용해야한다.
			// 이 이중포인터를 해제시켜주려면 위와 같이 행을 가리키는 포인터를 먼저 해제시키고, 그 다음에 배열 자체를 가리키는 포인터를 해제시켜야한다
		}

	}
	
	void Read(char* meg = "CCebMatrix"){ // 행렬의 행과 열의 수와 행의 내용을 사용자로부터 입력받기 위한 함수 
	/*여기서 Read 함수 안의 인수인 char* meg은 Read 함수를 부를 때 Read("행렬A")와 같이 호출 할 수 있도록 하는 것이고,
	그 안에 CCebMatrix는 만약 개발자가 저와 같이 호출하지 않고 Read() 함수만 호출한다면, 대신 값을 넣어줄 디폴트 값이라는 것이다
	만약 개발자가 따로 설정하지 않으면 디폴트 값이 들어간다*/

		int r,c; // 행렬의 행과 열의 갯수를 입력할 변수 선언
		
		printf("\t%s의 행과 열의 크기를 입력하시오 : ",meg); 
		// 함수의 인수인 meg 출력과 동시에
		// 사용자로부터 행과 열의 수를 입력하라는 메세지를 출력한다
		scanf("%d %d", &r, &c); // 사용자로부터 받은 행과 열의 수를 각각 변수 r,c에 대입한다
		AllocMem(r,c); // 실제 메모리를 할당하는 함수인 AllocMem을 호출한다

		if(!(r <= 0 || c <= 0)){ // 만약 행과 열의 수가 0보다 작거나 같은 것이 없다면
		printf("\t %dx%d개의 항목 값을 입력하시오 : ", r,c); // 사용자로부터 행렬의 값을 입력하라는 메세지를 출력한다
		for(int i = 0 ; i < r ; i++){ // 바깥 반복문은 행의 크기만큼 반복문을 돌고
			for(int j = 0 ; j < c; j++) // 안쪽 반복문은 열의 크기만큼 반복문을 돌면서
				scanf("%lf", &(m_elem[i][j])); // 사용자한테 입력받은 값을 이차원 배열에 넣어준다
		}
		printf("\n");
		}
	};


	
	void Print(char *meg = "CCebMaxtrix"){ // 사용자에게 입력받은 행과 열의 수와 그 배열의 값을 보기 좋게 출력하는 함수
				
		if(!(m_rows <= 0 || m_cols <= 0)) { // 만약 행과 열의 수가 0보다 작거나 같은 것이 없다면 행렬의 이상이 없다는 것이므로 다음을 실행시킨다
			/* 위에서 행과 열의 수가 0보다 작거나 같은 경우를 배제해줬지만, 
			이렇게 하는 이유는, Add 함수에서 두 행렬의 행과 열의 수가 0보다 작거나 같아도 두 행렬의 행과 열의 수가 같으면 덧셈을 하므로, 
			그렇게 연산된 것을 출력하지 않도록 하기 위해서이다*/
			printf("\n\t%s [%d x %d]: \n ", meg, m_rows, m_cols); // 개발자가 Print 함수를 호출할 때 입력한 메세지인 meg을 출력하고, 행과 열의 수를 출력한다.  

		for(int i = 0 ; i < m_rows ; i++)  // 이중 반복문 중에 바깥 반복문을 0부터 m_rows-1 까지 돌면서
		{
			printf("\t");
			for(int j = 0; j < m_cols ; j ++ ) // 안쪽 반복문을 0부터 m_cols-1 까지 돌면서
			{
				printf("%8.1lf",m_elem[i][j]); // 해당되는 행렬의 값을 출력한다
			}
			printf("\n");
		}

		}
	};

	void Add(CCebMatrix &a, CCebMatrix &b){ // 두 행렬의 덧셈을 수행하는 함수
		
		if((a.m_rows != b.m_rows) || (a.m_cols != b.m_cols)){ 
			/*기본적으로 두 행렬이 연산을 할 때 두 개의 행과 열의 수가 같아야 한다. 
			만약 하나라도 다르면 연산을 수행할 수  만약 하나라도 다르면 다음과 같은 메세지를 출력*/
			printf("\n\t[연산오류]\n\t   연산이 제대로 이루어지지 않아 행렬을 출력할 수 없습니다\n\n");
			return; // 그리고 return을 통해 함수를 빠져나온다
		}

		else{ // 만약 하나라도 다르지 않다면(두 행렬의 행과 열의 수가 같다면)
			AllocMem(a.m_rows, a.m_cols); 
			// 객체 c는 아직 객체만 생성되고, 메모리 할당이 되지 않았으므로, 메모리 할당을 해준다. 
			// 여기서 행과 열의 갯수는 a와 같으므로 a의 값을 넣어주면 된다(b의 값을 넣어줘도 전혀 문제가 없다)

			for(int i = 0 ; i < m_rows ; i ++) // 이중 반복문을 돌면서  
			{
				for(int j = 0 ; j < m_cols ; j++)
					m_elem[i][j] = a.m_elem[i][j] + b.m_elem[i][j]; // 각각의 행렬에 해당하는 값을 더해 클래스의 멤버변수인 m_elem에 대입한다

			}
		}
	}
	
};

